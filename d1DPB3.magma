getCo := function(poly,m)
	bool := exists(i){i:i in [1..#Monomials(poly)] | Monomials(poly)[i] eq m};
	if bool then
		return Coefficients(poly)[i];
	else
		return 0;
	end if;
end function;

R<l>:=PolynomialRing(Rationals());

A<r,s,t,u,a,b,c> := AffineSpace(Rationals(),7);

CR := CoordinateRing(A);

FCR := FieldOfFractions(CR);

P1Aux<x1,y1,z1,w1> := ProjectiveSpace(FCR,[1,1,1,3]);
P2Aux<x2,y2,z2,w2> := ProjectiveSpace(FCR,[1,1,2,3]);

P1:=ProjectiveSpace(Rationals(),[1,1,1,3]);
P2:=ProjectiveSpace(Rationals(),[1,1,2,3]);

squareZaux := map<P1Aux->P2Aux | [x1,y1,z1^2,w1]>;

toRing := function(polyList)
	f2R := hom< FCR -> CR |r,s,t,u,a,b,c>;
	newList := f2R(polyList);
	return(newList);
end function;

auxAdj := function(field) 
	Anew := ChangeRing(A,field);
	CRnew := CoordinateRing(Anew);
	FCRnew := FieldOfFractions(CRnew);
	out := ProjectiveSpace(FCRnew,[1,1,2,3]);
	return out;
end function;

getEqns := function(poly) /* this poly should be of the form w1^2-sextic */
	schemeProj := squareZaux(Scheme(P1Aux,poly)); /* project to the deg 1 del Pezzo */
	polyProj := DefiningPolynomial(schemeProj); /* extract the polynomial defining schemeProj */	
	Q := a*x2^2+b*x2*y2+c*y2^2; 
	C := r*x2^3+s*x2^2*y2+t*x2*y2^2+u*y2^3; /*these are the equations defining the divisors as in Thm 1.5.9 of V-Aâ€™s thesis*/
	compPoly := Evaluate(polyProj,[x2,y2,Q,C]); /* substitute Q,C into the defining eqn */
	eqnList := [getCo(compPoly,Monomials(compPoly)[i]): i in [1..#Monomials(compPoly)]]; /* get eqns for coeffs */
	newList := toRing(eqnList);
	return schemeProj, newList;
end function;

getTuples := function(polyList) /*run this using the list from getEqns.*/
	I :=ideal<CR | polyList>;
	gb := GroebnerBasis(I);
	f := gb[#gb];
	unif := Evaluate(f,[0,0,0,0,0,0,l]);
	splf := SplittingField(unif);
	facto := Factorization(unif);
	appendGb := [GroebnerBasis(Ideal(I,Evaluate(facto[i,1],c))): i in [1..#facto]];
	sys := [Scheme(A,appendGb[i]): i in [1..#appendGb]];
	points := <Points(sys[i],splf): i in [1..#sys]>;
	return splf, appendGb, points;
end function;

dpDivisors := function(space, scheme, tupleList) /*take space to be P2L, list from getTuples, scheme from getEqns*/
	nf := #tupleList;
	ns := space;
	divs := < <Scheme(ns,[ns.3-(tupleList[i,j,5]*ns.1^2+tupleList[i,j,6]*ns.1*ns.2+tupleList[i,j,7]*ns.2^2), ns.4-(tupleList[i,j,1]*ns.1^3+tupleList[i,j,2]*ns.1^2*ns.2+tupleList[i,j,3]*ns.1*ns.2^2+tupleList[i,j,4]*ns.2^3)]): j in [1..#tupleList[i]]> :  i in [1..nf]>;

	return divs;
end function;

function GramMatrixD(List)

m:=#List;
M:=ScalarMatrix(Integers(),m,-2);
k:=1;

for i in [1..m] do
    for j in [1..i] do
	Int:=List[i] meet List[j];
        if Dimension(Int) eq 1 then
	    M[i,j]:=2*ArithmeticGenus(Int)-2;
		/*print k, M[i,j];
		k:=k+1;*/
	else
	    M[i,j]:=Degree(Int);
		/*print k, M[i,j];
		k:=k+1;*/
	end if;
	M[j,i]:=M[i,j];
    end for;
end for;

return M;

end function;

fS := x1^6+y1^6+z1^6-w1^2;
Xsch := Scheme(P1, fS);

Saux, eqnList := getEqns(fS);
L, grobbases, tups := getTuples(eqnList);

preK<z12>:=CyclotomicField(12);
lineF<lr>:=SplittingField(l^4-l^2+1);
preL1:=Compositum(preK,L);
L1:=Compositum(preL1,lineF);
zeta12:=L1!z12;
zeta6:=zeta12^2;
zeta3:=zeta12^4;

P1L1 := ProjectiveSpace(L1,[1,1,1,3]);
P2L1 := ProjectiveSpace(L1,[1,1,2,3]);

dplist := dpDivisors(P2L1, Saux, tups);
 
X1L1 := BaseChange(Xsch, P1L1);
X2L1 := Scheme(P2L1, P2L1.1^6+P2L1.2^6+P2L1.3^3-P2L1.4^2);

sqL := map<X1L1->P2L1 | [P2L1.1, P2L1.2, P2L1.3^2, P2L1.4]>;

preSkews := [dplist[1,1], dplist[1,4], dplist[3,1], dplist[4,2], dplist[2,2], dplist[5,1], dplist[6,3], dplist[7,1], dplist[2,3]];

skews := [Scheme(P2L1,[DefiningPolynomials(sch)[1],DefiningPolynomials(sch)[2]]): sch in preSkews];

prePbSkews := [Pullback(sqL,sch) : sch in skews];

lines:=
[
Scheme(P1L1, [P1L1.1+zeta12*P1L1.3,P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1-zeta12*P1L1.3,P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1+zeta12*P1L1.3,-P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1-zeta12*P1L1.3,-P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1+zeta12^3*P1L1.3,P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1+zeta12^3*P1L1.3,-P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1+(zeta12^3-zeta12)*P1L1.3,P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1-(zeta12^3-zeta12)*P1L1.3,P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1+(zeta12^3-zeta12)*P1L1.3,-P1L1.2^3+P1L1.4]),
Scheme(P1L1, [P1L1.1-(zeta12^3-zeta12)*P1L1.3,-P1L1.2^3+P1L1.4]),
Scheme(P1L1,[P1L1.2-zeta12*P1L1.3, P1L1.4-P1L1.1^3])
];

pbSkews := [BaseChange(sch, P1L1): sch in prePbSkews];

preDivs:=pbSkews /*cat lines*/;
divs:=Flat(preDivs);

CRL1<xL,yL,zL,wL>:=CoordinateRing(ProjectiveSpace(L1,[1,1,1,3]));

var:={xL,yL,zL};
perm:=Permutations(var);
S3:=[hom< CRL1 -> CRL1 | [g[1],g[2],g[3],wL] > : g in perm];

C6a:=[hom<CRL1->CRL1 | zeta6^i*xL, yL, zeta6^(-i)*zL,wL >: i in [0..5]];
C6b:=[hom<CRL1->CRL1 | xL, zeta6^i*yL, zeta6^(-i)*zL,wL >: i in [0..5]];

GG:=car<S3,C6a,C6b>;
G:=[s[1]*s[2]*s[3] : s in GG];

preGpb:=< [Scheme(P1L1,[t(DefiningPolynomials(divs[j])[1]), t(DefiningPolynomials(divs[j])[2])]): j in [1..#divs]]: t in G>;
Gpb:=Flat(Append(Flat(preGpb),lines));

p:=23;
F<alpha>:=GF(p^2);

Pol<v>:=PolynomialRing(F);

zeta12p:=Roots(v^12-1,F)[12,1];

defL:=v^6-6*v^5+36*v^4+8*v^3-24*v^2+16;

defL1:=v^12 - 12*v^11 + 105*v^10 - 368*v^9 + 906*v^8 + 1644*v^7 - 4267*v^6 - 504*v^5 - 702*v^4 - 2596*v^3 + 8817*v^2 - 1920*v + 5821;

PP<X,Y,Z,W>:=ProjectiveSpace(F,[1,1,1,3]);
PPW:=CoordinateRing(PP);

X1L1p:=BaseChange(X1L1,PP);

prePsi:=hom< preK->F | zeta12p>;
Psi1:=hom< L1->F | Roots(defL1,F)[12,1]>;
PsiP:=hom< CRL1->PPW | Psi1, [X,Y,Z,W]>;

GpbP:=[Scheme(PP,[PsiP(DefiningPolynomials(sch)[1]),PsiP(DefiningPolynomials(sch)[2])]): sch in Gpb];

/*AG:=GramMatrixD(GpbP);
LG:=Lattice(AG);
BG:=Basis(LG);
rk:=#BG; rk;
SolG:=Solution(AG,[Vector(b) : b in BG]);
MG:=Matrix(SolG);
GramG:=MG*AG*Transpose(MG);*/





