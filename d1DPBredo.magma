getCo := function(poly,m)
	bool := exists(i){i:i in [1..#Monomials(poly)] | Monomials(poly)[i] eq m};
	if bool then
		return Coefficients(poly)[i];
	else
		return 0;
	end if;
end function;

R<l>:=PolynomialRing(Rationals());

A<r,s,t,u,a,b,c> := AffineSpace(Rationals(),7);

CR := CoordinateRing(A);

FCR := FieldOfFractions(CR);

P1Aux<x1,y1,z1,w1> := ProjectiveSpace(FCR,[1,1,1,3]);
P2Aux<x2,y2,z2,w2> := ProjectiveSpace(FCR,[1,1,2,3]);

P1:=ProjectiveSpace(Rationals(),[1,1,1,3]);
P2:=ProjectiveSpace(Rationals(),[1,1,2,3]);

squareZaux := map<P1Aux->P2Aux | [x1,y1,z1^2,w1]>;

toRing := function(polyList)
	f2R := hom< FCR -> CR |r,s,t,u,a,b,c>;
	newList := f2R(polyList);
	return(newList);
end function;

auxAdj := function(field) 
	Anew := ChangeRing(A,field);
	CRnew := CoordinateRing(Anew);
	FCRnew := FieldOfFractions(CRnew);
	out := ProjectiveSpace(FCRnew,[1,1,2,3]);
	return out;
end function;

getEqns := function(poly) /* this poly should be of the form w1^2-sextic */
	schemeProj := squareZaux(Scheme(P1Aux,poly)); /* project to the deg 1 del Pezzo */
	polyProj := DefiningPolynomial(schemeProj); /* extract the polynomial defining schemeProj */	
	Q := a*x2^2+b*x2*y2+c*y2^2; 
	C := r*x2^3+s*x2^2*y2+t*x2*y2^2+u*y2^3; /*these are the equations defining the divisors as in Thm 1.5.9 of A-Vâ€™s thesis*/
	compPoly := Evaluate(polyProj,[x2,y2,Q,C]); /* substitute Q,C into the defining eqn */
	eqnList := [getCo(compPoly,Monomials(compPoly)[i]): i in [1..#Monomials(compPoly)]]; /* get eqns for coeffs */
	newList := toRing(eqnList);
	return schemeProj, newList;
end function;

getTuples := function(polyList) /*run this using the list from getEqns.*/
	I :=ideal<CR | polyList>;
	gb := GroebnerBasis(I);
	f := gb[#gb];
	unif := Evaluate(f,[0,0,0,0,0,0,l]);
	splf := SplittingField(unif);
	facto := Factorization(unif);
	adjA := ChangeRing(A,splf);
	appendGb := [GroebnerBasis(Ideal(I,Evaluate(facto[i,1],c))): i in [1..#facto]];
	sys := [Scheme(adjA,appendGb[i]): i in [1..#appendGb]];
	points := <Points(sys[i]): i in [1..#sys]>;
	return splf, points;
end function;

dpDivisors := function(field, scheme, tupleList) /*input field and list from getTuples, scheme from getEqns*/
	nf := #tupleList;
	ns := auxAdj(field);
	bcS := BaseChange(scheme, ns);
	divs := < <Scheme(ns,[ns.3-tupleList[i,j,5]*ns.1^2+tupleList[i,j,6]*ns.1*ns.2+tupleList[i,j,7]*ns.2^2, ns.4-tupleList[i,j,1]*ns.1^3+tupleList[i,j,2]*ns.1^2*ns.2+tupleList[i,j,3]*ns.1*ns.2^2+tupleList[i,j,4]*ns.2^3]): j in [1..#tupleList[i]]> :  i in [1..nf]>;
	return bcS, divs;
end function;

function GramMatrixD(List)

m:=#List;
M:=ScalarMatrix(Integers(),m,-2);
k:=1;

for i in [1..m] do
    for j in [1..i] do
	Int:=List[i] meet List[j];
        if Dimension(Int) eq 1 then
	    M[i,j]:=2*ArithmeticGenus(Int)-2;
		/*print k, i,j;*/
		k:=k+1;
	else
	    M[i,j]:=Degree(Int);
		/*print k, i,j;*/
		k:=k+1;
	end if;
	M[j,i]:=M[i,j];
    end for;
end for;

return M;

end function;

fS := x1^6+y1^6+z1^6-w1^2;
Xsch := Scheme(P1, fS);

Saux, eqnList := getEqns(fS);
L, tups := getTuples(eqnList);
SauxL, dplist := dpDivisors(L, Saux, tups);

P1L := ProjectiveSpace(L,[1,1,1,3]);
P2L := ProjectiveSpace(L,[1,1,2,3]);
 
X1L := BaseChange(Xsch, P1L);
X2L := Scheme(P2L, P2L.1^6+P2L.2^6+P2L.3^3-P2L.4^2);

sqL := map<X1L->P2L | [P2L.1, P2L.2, P2L.3^2, P2L.4]>;

preSkews := [dplist[1,1], dplist[1,4], dplist[3,1], dplist[4,2], dplist[2,2], dplist[5,1], dplist[6,3], dplist[7,1], dplist[2,3]];

skews := [Scheme(P2L,[DefiningPolynomials(sch)[1],DefiningPolynomials(sch)[2]]): sch in preSkews];

prePbSkews := [Pullback(sqL,sch) : sch in skews];

pbSkews := [BaseChange(sch, P1L): sch in prePbSkews];

CRL<xL,yL,zL,wL>:=CoordinateRing(ProjectiveSpace(L,[1,1,1,3]));

p:=23;
F<alpha>:=GF(p^2);

Pol<v>:=PolynomialRing(F);

defL:=v^6-6*v^5+36*v^4+8*v^4-24*v^2+16;

PP<X,Y,Z,W>:=ProjectiveSpace(F,[1,1,1,3]);
PPW:=CoordinateRing(PP);

Psi:=hom< L->F| Roots(defL,F)[6,1]>;
PsiP:=hom< CRL->PPW | Psi, [X,Y,Z,W]>;