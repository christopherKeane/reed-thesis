getCo := function(poly,m)
	bool := exists(i){i:i in [1..#Monomials(poly)] | Monomials(poly)[i] eq m};
	if bool then
		return Coefficients(poly)[i];
	else
		return 0;
	end if;
end function;

A<r,s,t,u,a,b,c> := AffineSpace(Rationals(),7);

CR := CoordinateRing(A);

FCR := FieldOfFractions(CR);

P1113<x1,y1,z1,w1> := ProjectiveSpace(FCR,[1,1,1,3]);
P1123<x2,y2,z2,w2> := ProjectiveSpace(FCR,[1,1,2,3]);

squareZ := map<P1113->P1123 | [x1,y1,z1^2,w1]>;

toRing := function(polyList)
	f2R := hom< FCR -> CR |r,s,t,u,a,b,c>;
	newList := f2R(polyList);
	return(newList);
end function;

getEqns := function(poly) /* this poly should be of the form w1^2-Norm */
	schemeProj := squareZ(Scheme(P1113,poly)); /* project to the deg 1 del Pezzo */
	polyProj := Polynomial(schemeProj); /* extract the polynomial defining schemeProj */	
	Q := a*x2^2+b*x2*y2+c*y2^2; 
	C := r*x2^3+s*x2^2*y2+t*x2*y2^2+u*y2^3; /*these are the equations defining the divisors as in Thm 1.5.9 of A-Vâ€™s thesis*/
	compPoly := Evaluate(polyProj,[x2,y2,Q,C]); /* substitute Q,C into the defining eqn */
	eqnList := [getCo(compPoly,Monomials(compPoly)[i]): i in [1..#Monomials(compPoly)]]; /* get eqns for coeffs */
	newList := toRing(eqnList);
	return schemeProj, newList;
end function;

getTuples := function(polyList) /*run this using the list from getEqns.*/
	I :=ideal<CR | polyList>;
	gb := GroebnerBasis(I);
	facto := Factorization(gb[#gb]);
	appendGb := [GroebnerBasis(Ideal(I,facto[i,1])): i in [1..#facto]];
	sys := [Scheme(A,appendGb[i]): i in [1..#appendGb]];
	points := [PointsOverSplittingField(sys[i]): i in [1..#sys]];
	return points;
end function;