getCo := function(poly,m)
	bool := exists(i){i:i in [1..#Monomials(poly)] | Monomials(poly)[i] eq m};
	if bool then
		return Coefficients(poly)[i];
	else
		return 0;
	end if;
end function;

R<p>:=PolynomialRing(Rationals());

A<r,s,t,u,a,b,c> := AffineSpace(Rationals(),7);

CR := CoordinateRing(A);

FCR := FieldOfFractions(CR);

P1113<x1,y1,z1,w1> := ProjectiveSpace(FCR,[1,1,1,3]);
P1123<x2,y2,z2,w2> := ProjectiveSpace(FCR,[1,1,2,3]);

squareZ := map<P1113->P1123 | [x1,y1,z1^2,w1]>;

toRing := function(polyList)
	f2R := hom< FCR -> CR |r,s,t,u,a,b,c>;
	newList := f2R(polyList);
	return(newList);
end function;

spaceAdj := function(field) 
	Anew := ChangeRing(A,field);
	CRnew := CoordinateRing(Anew);
	FCRnew := FieldOfFractions(CRnew);
	out := ProjectiveSpace(FCRnew,[1,1,2,3]);
	return out;
end function;

getEqns := function(poly) /* this poly should be of the form w1^2-Norm */
	schemeProj := squareZ(Scheme(P1113,poly)); /* project to the deg 1 del Pezzo */
	polyProj := Polynomial(schemeProj); /* extract the polynomial defining schemeProj */	
	Q := a*x2^2+b*x2*y2+c*y2^2; 
	C := r*x2^3+s*x2^2*y2+t*x2*y2^2+u*y2^3; /*these are the equations defining the divisors as in Thm 1.5.9 of A-Vâ€™s thesis*/
	compPoly := Evaluate(polyProj,[x2,y2,Q,C]); /* substitute Q,C into the defining eqn */
	eqnList := [getCo(compPoly,Monomials(compPoly)[i]): i in [1..#Monomials(compPoly)]]; /* get eqns for coeffs */
	newList := toRing(eqnList);
	return schemeProj, newList;
end function;

getTuples := function(polyList) /*run this using the list from getEqns.*/
	I :=ideal<CR | polyList>;
	gb := GroebnerBasis(I);
	f := gb[#gb];
	splf := SplittingField(Evaluate(f,[0,0,0,0,0,0,p]));
	facto := Factorization(f);
	adjA := ChangeRing(A,splf);
	appendGb := [GroebnerBasis(Ideal(I,facto[i,1])): i in [1..#facto]];
	sys := [Scheme(adjA,appendGb[i]): i in [1..#appendGb]];
	points := <Points(sys[i]): i in [1..#sys]>;
	return splf, points;
end function;

dpDivisors := function(field, scheme, tupleList) /*input field and list from getTuples, scheme from getEqns*/
	nf := #tupleList;
	newSpace := spaceAdj(field);
	bcS := BaseChange(scheme, newSpace);
	divs := < <Scheme(newSpace,[newSpace.3-tupleList[i,j,5]*newSpace.1^2+tupleList[i,j,6]*newSpace.1*newSpace.2+tupleList[i,j,7]*newSpace.2^2, newSpace.4-tupleList[i,j,1]*newSpace.1^3+tupleList[i,j,2]*newSpace.1^2*newSpace.2+tupleList[i,j,3]*newSpace.1*newSpace.2^2+tupleList[i,j,4]*newSpace.2^3]): j in [1..#tupleList[i]]> :  i in [1..nf]>;
	return bcS, divs;
end function;
	 
bcSquareMap := function(L) /*L must be the field of definition of the del Pezzo divisors*/
	P1113L:=ProjectiveSpace(FieldOfFractions(CoordinateRing(ChangeRing(A,L))),[1,1,1,3]);
	P1123L:=ProjectiveSpace(FieldOfFractions(CoordinateRing(ChangeRing(A,L))),[1,1,2,3]);
	squareZL := map <P1113L->P1123L | [P1113L.1,P1113L.2,P1113L.3^2,P1113L.4]>;
	return P1113L, P1123L, squareZL;
end function;

pbDPdivs := function(divList, space, map) /*input divisors, base-changed square map, and newspace from bcSquareMap*/
	nf := #divList;
	pb := < <Pullback(map,BaseChange(divList[i,j],space)) : j in [1..#divList[i]]> : i in [1..nf]>;
	return pb;
end function;

S, list := getEqns(w1^2-x1^6-y1^6-z1^6);
L, tups := getTuples(list);
SxL, dplist := dpDivisors(L,S,tups);